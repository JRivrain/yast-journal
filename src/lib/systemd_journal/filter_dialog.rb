require 'yast'
require 'time'

Yast.import "UI"
Yast.import "Label"

module SystemdJournal
  # Dialog allowing the user to set the filter used to display the journal
  # entries in SystemdJournal::ViewLogDialog
  class FilterDialog

    include Yast::UIShortcuts
    include Yast::I18n

    INPUT_WIDTH = 20

    def initialize(filter)
      @filter = filter
    end

    # Displays the dialog and returns user's selection of filter options.
    #
    # @return [Hash] filter options or empty Hash if user cancelled
    def run
      return nil unless create_dialog

      begin
        case Yast::UI.UserInput.to_sym
        when :cancel
          {}
        when :ok
          widgets_values
        else
          raise "Unexpected input #{input}"
        end
      ensure
          Yast::UI.CloseDialog
      end
    end

  private

    # Translates the value of the widgets to the structure used in the filter
    # 
    # @returns [Hash] Hash containing :time, :source and other keys only when
    #                 they are relevant
    def widgets_values
      values = {
        time: Yast::UI.QueryWidget(Id(:time), :CurrentButton),
        source: Yast::UI.QueryWidget(Id(:source), :CurrentButton)
      }
      if values[:time] == :dates
        values[:since] = time_from_widgets_of(:since)
        values[:until] = time_from_widgets_of(:until)
      end
      case values[:source]
      when :unit
        values[:unit] = Yast::UI.QueryWidget(Id(:unit_field), :Value)
      when :file
        values[:file] = Yast::UI.QueryWidget(Id(:file_field), :Value)
      end
      values
    end

    # Draws the dialog
    def create_dialog
      Yast::UI.OpenDialog(
        VBox(
          # Header
          Heading(_("Journal filter")),
          # Time options
          Frame(
            _("When"),
            RadioButtonGroup(
              Id(:time),
              VBox(*time_buttons)
            )
          ),
          VSpacing(0.3),
          # Source options
          Frame(
            _("Generated by"),
            RadioButtonGroup(
              Id(:source),
              VBox(*source_buttons)
            )
          ),
          VSpacing(0.3),
          # Footer buttons
          HBox(
            PushButton(Id(:cancel), Yast::Label.CancelButton),
            PushButton(Id(:ok), Yast::Label.OKButton)
          )
        )
      )
    end

    # Array of radio buttons to select the time frame
    def time_buttons

      # For each option, we'll need an id, a label and, optionally,
      # some extra widgets
      options = [
        [:current_boot, _("Since system's boot")],
        [:previous_boot, _("On previous boot")],
        [:dates, _("Between these dates"), HSpacing(1), *dates_widgets]
      ]
          
      options.map do |value, label, *widgets|
        Left(
          HBox(
            RadioButton(Id(value), label, @filter[:time] == value),
            *widgets
          )
        )
      end
    end

    # Array of radio buttons to select the source
    def source_buttons

      # For each option, we'll need an id, a label and, optionally,
      # some extra widgets
      options = [
        [:all, _("Any source")],     
        [:unit, _("This systemd unit"), HSpacing(1), unit_widget],
        [:file, _("This file (executable or device)"), HSpacing(1), file_widget]
      ]

      options.map do |value, label, *widgets|
        Left(
          HBox(
            RadioButton(Id(value), label, @filter[:source] == value),
            *widgets
          )
        )
      end
    end

    # Array of widgets for selecting date/time thresholds
    def dates_widgets
      [
        *time_widgets_for(:since),
        Label("-"),
        *time_widgets_for(:until)
      ]
    end

    # Array of widgets representing one if the time fields on @filter
    # (:since or :until), the result depends on the used UI (not all widgets are
    # available in all interfaces)
    def time_widgets_for(field)
      date = @filter[field].strftime("%Y-%m-%d")
      time = @filter[field].strftime("%H:%M:%S")
      widgets = []

      # DateField widget is not available in ncurses interface
      if Yast::UI.HasSpecialWidget(:DateField)
        widgets << DateField(Id(:"#{field}_date"), "", date)
      else
        widgets << MinWidth(11, InputField(Id(:"#{field}_date"), "", date))
      end
      # TimeField widget is not available in ncurses interface
      if Yast::UI.HasSpecialWidget(:TimeField)
        widgets << TimeField(Id(:"#{field}_time"), "", time)
      else
        widgets << MinWidth(9, InputField(Id(:"#{field}_time"), "", time))
      end
      widgets
    end

    # Reads the widgets representing one of the time fields from @filter.
    #
    # @returns [Time] Value specified by the user
    def time_from_widgets_of(field)
      Time.parse(
        Yast::UI.QueryWidget(Id(:"#{field}_date"), :Value) +
        " " +
        Yast::UI.QueryWidget(Id(:"#{field}_time"), :Value)
      )
    end

    # Widget representing @filter[:unit]
    def unit_widget
      current = @filter.fetch(:unit, "")
      MinWidth(INPUT_WIDTH, InputField(Id(:unit_field), "", current))
    end

    # Widget representing @filter[:file]
    def file_widget
      current = @filter.fetch(:file, "")
      MinWidth(INPUT_WIDTH, InputField(Id(:file_field), "", current))
    end
  end
end

